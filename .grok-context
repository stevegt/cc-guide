
### Pull Requests

*Pull requests are proposals for merging.*

A pull request is a proposal to merge a branch into a timeline.  This
can be useful in situations where a branch is ready to be merged into
the main timeline, but the branch owner does not have permission to
merge it themselves.  Pull requests can also be used to request
feedback or review from other parties before merging.

### Issues

*Issues are problems that need to be solved.*

An issue is a problem that needs to be solved.  This can be useful in
situations where a problem needs to be addressed, but the solution is
unclear or unknown.  Issues can be used to track problems that need to
be solved, and to coordinate the efforts of different parties to
resolve them.

### Pull Requests and Issues

*Pull requests and issues are complementary.*

Pull requests and issues are complementary.  Pull requests are used to
propose merging a branch into a timeline, and issues are used to
propose solutions to problems.  Pull requests and issues can be used
together to propose merging a branch that contains a solution to an
issue.

### Pull Requests, Issues, and Commits

*Pull requests, issues, and commits are complementary.*

Pull requests, issues, and commits are complementary.  Pull requests
are used to propose merging a branch into a timeline, issues are used
to propose solutions to problems, and commits are used to record
decisions, tasks, notes, plans, and milestones.  Pull requests,
issues, and commits can be used together to propose merging a branch
that contains a solution to an issue.

### Pull Requests, Issues, Commits, and Timelines

*Pull requests, issues, commits, and timelines are complementary.*

Pull requests, issues, commits, and timelines are complementary.
Pull requests are used to propose merging a branch into a timeline,
issues are used to propose solutions to problems, commits are used to
record decisions, tasks, notes, plans, and milestones, and timelines
are used to organize information.  Pull requests, issues, commits, and
timelines can be used together to propose merging a branch that
contains a solution to an issue.

### Pull Requests, Issues, Commits, Timelines, and Branches


In this sense, merging truly is where the "rubber meets the road." It
represents the point at which individual contributions are brought
together to create something greater than the sum of its parts.


Moreover, the merge problem is a challenge that exists in various
areas such as version control, project management, and event
coordination. The CC process and tooling are designed to promote
collaboration, reduce workload, and provide a transparent and open
process for coordinating projects and events. 

They leverage parallel
timelines, collaboration, and decentralization to help manage the
process of merging multiple parallel timelines. The goal of CC and the
GDO platform is to provide a flexible and accessible system for
coordinating projects and events that emphasizes collaboration and
consensus formation during the merging process.



Overall, timelines make solutions to the merge problem more obvious or transparent by creating a system that is flexible, decentralized, and transparent, promoting collaboration, communication, and efficient decision-making.

Additionally, timelines can be used to promote
transparency and reduce reliance on centralized systems, resulting in
improved security and resilience.




# Types of Community Coordination

There are two main types of community coordination -- most communities
combine elements of both in a hybrid approach:

1. **Synchronous Community Coordination**:  This is the process of
   participating synchronously during virtual or in-person meetings
   and events.  This is covered in the [Synchronous Community
   Coordination](#synchronous-community-coordination) section.
2. **Asynchronous Community Coordination**:  This is the process of
   participating asynchronously through electronic communication and
   collaboration tools.  This is covered in the [Asynchronous
   Community Coordination](#asynchronous-community-coordination)
   section.

2. Flexible Coordination: CC is designed to accommodate various use
cases, from personal to-do lists and organizational calendars to code
repositories and project management tools.

3. Collaboration: The system fosters teamwork by providing tools for
communication, document sharing, and real-time editing.

4. Decentralization: CC leverages decentralized technologies to store
data, ensuring greater security, privacy, and resilience.

5. Accessibility: CC is built to be user-friendly and can be accessed
   through modern web browsers, making it available to a diverse range
   of users and devices.

## Benefits of Using CC

Implementing CC within a community or organization can yield numerous benefits:

- Improved organization and planning through the use of parallel
  timelines and flexible coordination tools.
- Enhanced collaboration between team members, leading to more
  efficient decision-making and problem-solving.
- Greater transparency, as changes and updates are recorded and
  visible to the entire community.
- Reduced reliance on centralized systems, resulting in improved
  security and resilience.


## Who Can Use CC?

CC is designed for a wide range of users, including:

- Individuals seeking a better way to manage their personal tasks and
  activities.
- Teams or organizations looking to improve collaboration, project
  management, and decision-making.
- Developers and software teams in need of a decentralized,
  collaborative code management system.
- Event planners and coordinators who require a flexible, accessible
  platform for organizing and executing events.

In summary, Community Coordination (CC) is a versatile and accessible
system for managing and organizing individual and collective
activities. By leveraging key concepts like parallel timelines,
collaboration, and decentralization, CC aims to


XXX a timeline is a DSl

Branches can also be used when there are two or more parties working
on solutions to a problem using different approaches, and need freedom
to explore.  The various branches can then be merged later during
reconciliation.

Both terms have a specific meaning in the context of version control
systems. "Merge" is commonly used to describe the process of combining
the changes made in different branches into a single branch. On the
other hand, "reconcile" is typically used to describe the process of
resolving conflicts between different versions of the same file or
document.

In terms of accessibility, "merge" is more commonly used and
understood by non-technical users, especially those who are familiar
with basic version control concepts. However, it's always best to use
the terminology that is most appropriate and clear for the specific
context and audience.


Timelines address the merge problem by providing a mechanism whereby
multiple parallel timelines can be managed independently. By using
parallel timelines, teams or communities can maintain their own unique
versions or perspectives of events, while still working together
towards common goals. The reconciliation or merging of parallel
timelines can help to bring together different perspectives and
approaches, leading to more informed decision-making and a more
cohesive outcome. 

Overall, the use of parallel timelines in managing the merge problem
provides a flexible, decentralized, and transparent system for merging
or coordinating between multiple parties, promoting collaboration,
communication, and efficient decision-making.

promoting collaboration, communication, and
transparency, and by providing a platform for efficient and effective
decision-making, we hope to help communities and organizations
overcome the challenges inherent in "the merge problem" and ultimately
achieve their goals.

### The CC Process

The CC process is a set of guidelines and best practices for
organizing and managing projects and events using timelines. The
process is designed to be flexible and adaptable, and can be used to
coordinate a wide range of activities, including projects, events,
meetings, and other types of work. 

The CC process is based on the following principles:

* **Accessibility** - The CC process and tooling are designed to be
  accessible to a wide range of users, including those with
  technical and non-technical backgrounds. The process and tooling
  are designed to be easy to learn and use, and to be accessible to
  people with disabilities. 

* **Collaboration** - The CC process and tooling are designed to
  promote collaboration and accountability, and to reduce the
  workload of project and event organizers. The process and tooling
  are designed to be transparent and open, and to provide a
  consistent and predictable process for coordinating projects and
  events. 

* **Adaptability** - The CC process and tooling are designed to be
  adaptable to a wide range of situations and needs. The process and
  tooling are designed to be flexible and customizable, and to
  support a wide range of use cases. 

### The CC Tooling

The CC tooling is a set of software tools that support the CC process.
The tooling is designed to be easy to learn and use, and to be
accessible to people from diverse backgrounds. The tooling is designed
to be flexible and customizable, and to support a wide range of use
cases. 

The CC tooling is based on the following principles:


Overall, parallel personal timelines are a versatile and powerful tool
for personal organization, planning, and collaboration. By enabling
   individuals to manage multiple commitments, explore different
   scenarios, and coordinate with others, parallel timelines can help
   to increase efficiency, reduce stress, and promote better outcomes.


Each timeline can have its own unique set of commits that diverge from
the main or canonical timeline, allowing for different scenarios or
options to be explored without affecting the integrity of the main
timeline. When it comes time to merge these divergent timelines, a
proposal and review process can be used to ensure that all changes are
thoroughly considered and any conflicts are resolved.

This reconciliation or merging of parallel timelines can help to bring
together different perspectives and approaches, leading to more
informed decision-making and a more cohesive outcome. By using
parallel timelines, teams or communities can maintain their own unique
perspectives or versions of events, while still working together
towards a common goal. And 

   Through parallel timelines, collaboration, communication, and efficient decision-making can be promoted, ultimately leading to better outcomes.

Parallel personal timelines are similar to parallel timelines for
communities or organizations, but are designed for individual use.
They allow individuals to create and manage multiple versions or
scenarios of personal timelines, each with their own distinct set of
commits or events. This can be useful for personal organization, goal
tracking, or managing multiple projects or tasks simultaneously. 

Like community timelines, personal timelines can have branches for
different versions or scenarios, with each branch representing a
different set of commits or events. This allows individuals to
experiment with different approaches or ideas, without worrying about
affecting the rest of their timeline. 

Overall, parallel personal timelines are a powerful tool for personal
organization and planning, allowing individuals to manage multiple
projects or goals with ease, and to explore different options and
scenarios without fear of negative consequences.

Parallel timelines for past events or commits can be used to explore
alternative scenarios or options that could have had a different
outcome, or to analyze how different decisions or actions could have
affected the outcome of an event. For example, in a historical
context, parallel timelines could be used to explore how certain
historical events might have turned out if different decisions or
actions had been taken, or if certain individuals or groups had not
been involved. 

In the context of version control systems, parallel timelines for past
commits can be used to maintain multiple versions of a codebase or
document that have diverged from the main or current version. This can
be useful in situations where different groups or individuals are
working on different versions of a project, or where a project has
different branching paths that need to be tracked and managed
separately. 

Regardless of the context, parallel timelines for past events or
commits allow for a more nuanced understanding of the various
decisions and actions that led to the outcomes of different scenarios
or versions of a timeline, and provide a means to compare and contrast
different options or alternatives.

Parallel timelines allow for multiple scenarios or versions of the
future to exist concurrently without affecting the main or canonical
version of the timeline. 

This feature helps prevent merge conflicts
and promotes transparency and decentralized systems resulting in
improved security and resilience. Overall, parallel timelines offer
more flexibility and control over the management and organization of
information and events, making them useful for coordinating between
multiple parties in exploring different scenarios or options.

Parallel timelines are particularly useful when merging or
coordinating between multiple parties because they allow for different
versions or scenarios to exist concurrently without affecting the main
or current version of the timeline. Multiple parties can work on
different branches and test their changes independently without
causing conflicts, and can then merge their changes onto the main
timeline using a proposal and review process, which ensures that all
changes are thoroughly considered before being finalized. 

This feature helps to prevent merge conflicts, as each branch can be
managed separately and edited without impacting the other branches. In
addition, the parallel timelines can be used to represent different
stages of development, allowing for different parties to work on
different parts of the project and merge their work once it is ready.
By providing a flexible, decentralized, and transparent system for
merging or coordinating between multiple parties, the use of parallel
timelines can promote collaboration, communication, and efficient
decision-making.

Parallel timelines are useful in the real world because they allow for
the exploration of different scenarios or options without affecting
the main or current version of the timeline. This can be especially
useful in situations where multiple options are available, or where
decisions or changes may have significant implications. Parallel
timelines can also be beneficial in promoting transparency, as changes
and updates are recorded and visible to the entire community. In
addition, they can reduce reliance on centralized systems, resulting
in improved security and resilience. Overall, parallel timelines offer
more flexibility and control over the management and organization of
information and events.

This allows for easy organization, comparison, and conflict resolution
between different versions of documents, code, or plans. Branches can
also be used to represent different stages of development or
experiments before merging with the main timeline. 

Timelines can be used to promote transparency, and can reduce reliance
on centralized systems, resulting in improved security and resilience.




### The CC Process

The CC process is a set of guidelines for coordinating projects and
events, and is designed to be flexible and adaptable to the needs of
the group, team, or community. The CC process is based on the
following principles:

* **Accessibility** - The CC process is designed to be accessible to
  a wide range of users, including those with technical and
  non-technical backgrounds. The CC process is also designed to be
  accessible to users with disabilities, and is compliant with
  [WCAG 2.0](https://www.w3.org/TR/WCAG20/).

* **Collaboration** - The CC process is designed to facilitate
  collaboration between members of a group, team, or community. The
  CC process is also designed to facilitate collaboration between
  members of a group, team, or community and external stakeholders,
  including sponsors, partners, and funders.

* **Adaptability** - The CC process is designed to be adaptable to
  the needs of the group, team, or community. The CC process is
  designed to be flexible and scalable, and can be used to coordinate
  a wide range of projects and events, from small, informal projects
  to large, complex projects.

* **Transparency** - The CC process is designed to be transparent to
  the members of a group, team, or community. The CC process is
  designed to be open and inclusive, and to encourage participation
  from all members of a group, team, or community.

* **Accountability** - The CC process is designed to be accountable
  to the members of a group, team, or community. The CC process is
  designed to be transparent and inclusive, and to encourage
  participation from all members of a group, team, or community.

* **Sustainability** - The CC process is designed to be sustainable
  for the group, team, or community.




## Key Features

1. Parallel Timelines: CC enables users to create and manage multiple
   parallel timelines, allowing for easy organization, comparison, and
   conflict resolution between different versions of documents, code,
   or plans.
2. Commits (Point?  Event?): These are the individual units of
   information that make up a timeline. A change in a doc, or related
   changes in several docs or code files, is a commit. Commits can
   describe past or future events or ongoing processes. They may be
   written in either natural or machine-readable language, depending
   on the needs of the community.
3. Branches: Branches are used to represent different versions of a
   timeline. For example, a timeline might have a "main" branch that
   represents the current state of the timeline, and a "draft" branch
   that includes all of the commits from the main branch with one or
   more new commits appended to the end.
4. Keys (Label?): A key is a unique identifier that is used to refer
   to a specific commit. Each commit must include the key of the
   previous commit in the timeline.  The key of the last commit in a
   timeline is used as both the version number of the timeline and an
   identifier of the timeline itself. Keys are computer-generated
   based on the content of the commit, are unique, and can be used to
   verify that the commit has not been altered.
5. Links: A link is a key referencing a specific commit in another
   timeline. Links can be used to represent dependencies between
   timelines, such as a timeline that depends on another timeline for
   resources or procedures. A community using CC will always link to a
   commit in this document's timeline to indicate which version of the
   CC process they are following.


## Timeline Lifecycle

A timeline consists of commits or events that are frozen and
referenced using a unique identifier, and can have multiple branches
to represent different versions or scenarios. Changes to a timeline
are made through a proposal and review process, with options for
objection and conflict resolution. CC is designed to be flexible and
accommodate various uses, from personal to-do lists to project
management tools.

Anyone can create a new timeline. The first commit in a timeline
should describe 



include a link to an existing commit in another timeline that
describes the process for managing the timeline. 



timeline depends on. The first commit in a timeline should also

timeline, the intended audience, and any other information that would
be useful to someone who is unfamiliar with the timeline. The first
commit should also include a link to the previous commit in the

The timeline creator can delegate
others 
invite others to contribute to the timeline.  The timeline creator
can also create branches of the timeline, and invite others to

, and only the creator of a timeline
can append commits to it.  



k.  Ordinarily, a timeline is created
by branching from another timeline.

the main timeline of the community or project.  The
created to represent a community or project.  However, timelines can
also be created to represent other types of information, such as
procedures or policies.  The timeline lifecycle is as follows:

, but only the timeline's creator can
accept commits to it. The creator of a timeline is responsible for
maintaining the timeline and ensuring that it is kept up to date. The
timeline creator can also delegate the responsibility of maintaining
the timeline to another community member. The timeline creator can
also choose to make the timeline read-only, which means that no new




A commit is created by a community member and submitted to the
community for review. The community then reviews the commit and
decides whether to accept it. If the commit is accepted, it is
appended to the timeline. If the commit is rejected, it is discarded
and the community member who created it is notified of the reason for
the rejection. If the community member wishes to revise the commit,
they can do so and resubmit it for review.





A commit is added to a timeline in a series of stages. Each stage
might take place asynchronously or in a virtual or in-person meeting.
The stages are *plan, write, test, propose, and accept,* and they are
described in more detail below.

1. Plan: Implementers and stakeholders discuss the need for a commit
   and how it might be implemented. The plan might include
   user stories, use cases, or other documentation that describes the
   need. The plan might include a draft of the commit itself.
2. Write: This stage might include assembling and leading a working
   group to write the commit, or it might be written by a single
   person. A working group might include implementers, stakeholders,
   and other community members.  In either case, the author(s) of the
   commit write the commit and append it to a branch of the timeline. 
4. Test: The commit is reviewed and tested by a larger group of
   stakeholders. The procedure for testing must be described in 
   earlier commits on the same timeline.
3. Propose: The commit is proposed for inclusion in the main timeline
   branch.  This is done by notifying the community of the commit,
   providing a link to the commit, and asking for feedback.  The
   community has a period of time to review the commit and provide
   feedback.  The community may also propose changes to the commit








6. Acceptance:  Acceptance is the process of approving a commit. A commit
   must be accepted by another timeline; a timeline cannot accept its
   own commits. 
   must be "opened" to accept commits, and then a commit must be
   "submitted" to the timeline for acceptance. A timeline can be
   opened or closed at any time, and a commit can be submitted to a


   the timeline that accepts the
   commit is called the "acceptor".  The acceptor may be the same



   Acceptance is a collaborative process that involves
   multiple community members. Acceptance is required for all commits
   to the main branch of a timeline. Acceptance is not required for
   commits to other branches, but it is recommended.

the process of reviewing and approving
   commits.  

   When a  accepts a new commit in layer
   1, they signify this by adding a layer 2 commit that
   includes the key of the layer 1 commit.  If the layer 1 community


   Synonyms for "reference" include "link", "cite", "point to", and
   "point at".  The term "reference" is used here because it is
   unambiguous and has a clear meaning in both natural and
   machine-readable languages.  The term "link" is avoided because it
   is ambiguous and has different meanings in different contexts.


   commit in this document as 
   then create additional timelines in layer two, and so on.  This
   commit for this document as the parent key.  The community's


   multiple layers, each representing a different aspect of the
   community or project. For example, a community may have a layer
   for the community's governance, a layer for the community's
   technical processes, and a layer for the community's technical
   documentation. Each layer may have its own timeline, or may share

   changes that add up to the current
   up this document is always layer zero.  A
   timeline of documents that a group creates while using this
   document to organize their efforts is layer 1, a subgroup or
   project might be layer 2, and so on.  Layers are a more abstract
   concept in CC, so we'll devote a whole section to them later.
   





     
      


3. Meetings: Meetings are an optional part of the CC system -- CC
   facilitates meetings, but also supports asynchronous interaction.
   CC categorizes meetings into three types -- planning, writing, and
   testing.  More on this later.


# Layers


   document is CC Layer 0.  Higher layers build upon lower layers Layers can be written by different
   communities, with each community building upon the foundation of
   the lower layers. This allows for different communities, groups, or
   projects to use their own specific processes and workflows, while
   still relying on the shared information and structure provided by
   the lower layers. The lower layers serve as a foundation for the
   higher layers, providing a consistent and reliable foundation for
   decision making and execution.

Layer | Community, Group, or Project
----- | ------------------------------------
2     | local renewable energy project 
1     | Smart City community document series
0     | CC guide (this document)


## Implementation

The CC system can be implemented using a variety of tools and
technologies, depending on the needs of the community. This might
include document management systems, version control systems, chat
platforms, and more. The key is to choose tools that are accessible,
flexible, and scalable, so that the community can continue to grow and
evolve over time.

## Meetings

CC uses three main types of meetings to manage project development:
Design Meetings, Write Meetings, and Test Meetings. The focus of each
meeting is to ensure that the project is moving forward in a
coordinated and organized manner.

Design Meetings are used to define the scope, goals, and requirements
of a project. Participants in a Design Meeting are expected to review
relevant docs prior to the meeting and come prepared to discuss the
project.

Write Meetings are used to write and update the project's docs.
Participants in a Write Meeting are expected to review relevant docs
prior to the meeting and come prepared to work on the project's docs.

Test Meetings are used to test and validate the project's docs and
code. Participants in a Test Meeting are expected to review relevant
docs and code prior to the meeting and come prepared to test and
validate the project.

## Implementation
To implement CC in your community, follow these steps:
1. Define the community's goals and objectives.
2. Establish the community's timeline.
3. Schedule and hold Design Meetings to define the scope, goals, and requirements of projects.
4. Schedule and hold Write Meetings to write and update project docs.
5. Schedule and hold Test Meetings to test and validate project docs and code.

By following these steps, your community will be able to coordinate and manage its projects effectively and efficiently.


CC Quick Start

Choose a community or project to work with. This will be the top-level timeline for your work.


Share your work with your community or project by sending a proposal. A proposal is a request for the community or project to accept your work as part of their timeline.

If your proposal is accepted, your work becomes a commit in the community or project timeline.

Repeat steps 2-4 as needed to make additional changes to your work and have them accepted into the timeline.

Use the community or project timeline as a reference for your work, and refer to it in your own documents and scripts.

Participate in meetings and discussions with your community or project to coordinate your work and resolve any issues that arise.

With these simple steps, you can begin using CC to manage your work and collaborate with your community or project.


# CC Quick Start

To get started with CC, follow these steps:

1. Start a timeline. This will serve as the foundation for all
   future records, scripts, and meetings.
2. Create a new document or set of documents and/or code that describe
   your work. These documents will be the first commit in your
   timeline, and should decribe how future commits will be accepted or
   rejected.

3. Write down the current state of your community or project in the
   form of a script. This script should describe the community or project's
   goals, processes, and current issues.
4. Use the script to guide discussions and decision-making in
   meetings. Meetings should be focused on making progress towards
   the goals described in the script.
5. After each meeting, update the script to reflect any decisions
   or changes made during the meeting.
6. Repeat steps 3 and 4 as needed to continue making progress.




# Call for Objections

The Call for Objections (CFO) process is a method used in CC to gather
feedback and objections before making a change to a timeline.  While 
the CFO process is optional, it is recommended that a timeline owner
use this process for changes:

XXX reconcile owner with proposer

1. A proposal is made: A change to the timeline is proposed, usually
   by a member of the community. This can be in the form of a document
   or a discussion in a meeting.
2. Call for Objections: The proposer issues a CFO, inviting the
   community to review the proposal and voice any objections they may
   have. The CFO should specify the deadline for objections and the
   means by which objections can be raised (e.g. email, discussion
   forum, etc.).
3. Review and Discussion: The community reviews the proposal and
   discusses any objections they may have. This can be done through
   email, discussion forums, or in a meeting.
4. Resolve Objections: The proposer works with the community to
   resolve any objections raised during the review and discussion
   phase. This may involve revising the proposal, seeking additional
   input, or finding alternative solutions.
5. Finalize Change: If objections are resolved, the proposal is
   accepted and the change is made to the timeline. If objections
   cannot be resolved, the proposal may be withdrawn or revised.

The CFO process helps to ensure that changes to the timeline are made
with the full consideration of the community and that any potential
impacts are understood and addressed.


## Tests

The tests on a timeline serve as the rules for determining which
branch is considered the trunk. In the event of a conflict, the tests
must specify how to resolve the issue and determine which branch
should be considered the trunk. The tests could include factors such
as code review, human approval, or any other criteria that the
timeline owner considers important for making this decision.

The owner does not manually tag the trunk. The prior tests on the
timeline are used to determine which branch is the trunk, and these
tests must include instructions on how to resolve conflicts in case
there are multiple branches that pass the tests. The process is
automated and follows the rules specified in the tests.

## Testing in CC

Testing is an integral part of the CC process, as it helps to ensure
the quality and correctness of new nodes being added to the timeline.
Every node is automatically considered committed and the "trunk" tag
moved to it only if it passes the tests that are already on the
branch. 

It is important to note that anyone should be able to perform the
tests, and the tests themselves may include a requirement for a
verifiable signature from a given human, group, or other private key,
allowing for human review and approval to be part of the acceptance
process. 

The tests on the timeline are designed to determine which branch is
considered the "trunk". In the event of a conflict, the tests
themselves must describe what to do. The owner of the timeline does
not directly tag the "trunk", as the tests are responsible for
determining it.

It is important to carefully consider the tests that are included on
each timeline, as they play a crucial role in ensuring the quality and
reliability of the information that is being recorded.

## Node Lifecycle

In CC, nodes are the building blocks of a timeline. Once a node is
added to a timeline, it is frozen and cannot be modified. Instead, if
a change is needed, a new node can be added to the timeline that
supersedes or updates the previous node. 

The key, or unique identifier, of a node is used to reference it
within the timeline. This allows for a clear, historical record of all
changes and decisions made within the timeline. 

It is important to carefully consider the content and impact of a node
before adding it to the timeline, as it will become a permanent part
of the timeline's history.

## Node Lifecycle

The CC node lifecycle is a flexible and open process that allows for
the creation and integration of new nodes into a timeline. The
following steps outline the process:

1. Authoring: An author writes and tests a new node.

2. Commit: If the node passes the existing tests on a branch, it is
   considered to be committed. The node is added to the timeline and
   its key is stored in the branch's history.

3. Call for Objections (CFO): The author posts a message to the
   appropriate communication channel, calling for objections to the
   proposed node. The message should include the date by which
   objections must be raised.

4. Testing and Trunk Recognition: If there are no objections, the node
   is considered to be the tip of the new trunk. The branch's existing
   tests are used to determine which node should be the tip of the
   trunk. The tests themselves must describe how to handle conflicts
   in the event that multiple branches pass the tests.

Note: Nodes can reference earlier nodes on any timeline branch,
creating a tree-like structure of branches linked together
chronologically by the keys of existing nodes.

## Data Structures

### Timeline

A timeline is a branch.

that are linked together
chronologically by the keys of existing nodes. The timeline is the

### Node

### TODO

XXX distributed multi-user machine, cpu, storage, executable,
development

XXX how do we incentivize users to store data?

Timelines: Timelines are the core structure of the CC system. Each
   timeline represents a series of events, records, or scripts that
   describe the history and future of a community or project.
   Timelines are used to capture and organize important information,
   decisions, and procedures.  

## Quick Start

If starting use of CC in a new group, community, or organization, go
to the [Startup Checklist](#startup-checklist). 

If CC startup is done and you are hosting a synchronous event, go to the
[Synchronous Checklist](#synchronous-checklist).

If CC startup is done and you are supporting an asynchronous
community, go to the [Asynchronous Checklist](#asynchronous-checklist).

## Startup Checklist

This is an interim procedure that will be superceded by a more
automated process.  Until then:

- [ ] Fork [this repository](https://github.com/stevegt/cc-guide) on
  github.
- [ ] Edit the [config.yaml](config.yaml) file to reflect your
  community's information, including preferred URLs and tools.
- [ ] Run `make` in your repository's top-level directory to generate
  the [index.html](index.html) file.
- [ ] Commit and push your changes.
- [ ] In your repository's settings, enable github pages to serve the
  `main` branch root directory.
- [ ] Provide your repo URL to participants using {{.ANNOUNCE_LINK}}

## Synchronous Checklist

This is an interim procedure that will be superceded by a more
automated process.  Until then:

### Before event

- [ ] Propose the event at {{.PROPOSAL_LINK}}
- [ ] Collect participant availability at {{.WHEN_LINK}}
- [ ] Confirm the date and time at {{.WHEN_LINK}}
- [ ] Announce the event at {{.ANNOUNCE_LINK}}
- [ ] Send a reminder at {{.ANNOUNCE_LINK}}
- [ ] ggXXX



2. Call for Objections:  Submitting the commit automatically creates a
   "call for objections" (CFO), inviting the community or project
   members to review the proposal and voice any objections they may
   have. The deadline and means for raising objections should be
   clearly stated.

3. Review and Discussion: The community or project members review the proposal and discuss any objections or concerns they may have. This can be done through email, discussion forums, or in a meeting.

4. Resolve Objections: The proposer works with the community or project members to resolve any objections or concerns raised during the review and discussion phase. This may involve revising the proposal, seeking additional input, or finding alternative solutions.

5. Acceptance: If objections are resolved, the community or project
   members accept the proposal and the change is made to the timeline
   or project plan. If objections cannot be resolved, the proposal may
   be withdrawn or revised.

The proposal process ensures that significant changes are thoroughly
considered and discussed before they are made. It promotes
collaboration and transparency by allowing all members of the
community or project to contribute their ideas and raise potential
concerns. This process helps to build consensus and ensure that
changes are made in a constructive and inclusive manner.


In the context of CC (Collaborative Consensus), testing is an integral
part of the CC process and is used to validate new commits being added
to the timeline. Participants are expected to review relevant
documentation and code ahead of Test Meetings and are tasked with
testing and validating the project to ensure its quality and
correctness.

Similar to a legislature voting on an amendment, testing a commit
involves assessing its quality and making a decision about whether to
accept or reject it. In both cases, there may be rules or criteria
that need to be met in order for a proposal to be accepted. 

"Proposals are the birth of ideas, brought forth from the imagination of individuals and presented for scrutiny by the collective. They serve as exploratory vessels, navigating the choppy waters of possibility and seeking to find common ground amidst a sea of differing opinions."

"A proposal is an opportunity to gather input, reconcile differences, and make decisions based on a solid foundation of recorded experience."

"A proposal enables group deliberation and resolves conflicts before making a final decision."

Tests whisper secrets,
To ensure a code's value. 
Quality assured.

Decisions are tough,
Testing provides a clear course,
Governance endures.

"Test early, test often. Code lives longer than its developer."

"Tests form the backbone of governance, a rigorous scientific approach."

"Testing is how we explore the universe of commitments."

"Assert goals, test progress, and implement change."

"If you can't test it, you can't govern it."

"Test-driven governance: progress by design, not by accident."

"Constraining power through testing: Govern thyself, before governing others."

"In test-driven governance, assertions are our guiding stars."

"Commit, test, refine - governance with a scientific touch."

"Test first, govern boldly."

"Test-driven governance: commit, test, iterate. Resilience through adaptation."

"Test-driven governance: Cyclical adaptation breeds resilience."

"Goals as commitments, tests as verifications, progress through iterations."

"Define goals, commit tests, implement changes. Adapt and innovate."

"Start with goals, test progress, and adapt to circumstances."
"Goal commit. Test commit. Progress commit. Repeat. Iterate." -Feynman
Iterative decision-making through commits with tests.
Iterative governance with continual learning, adaptation and automated testing.
Iterative process that prioritizes testing.
Continually test decisions and adapt for effective governance.
Test-driven governance = goals + tests + adaptation.
Test-driven governance: making sure we do things right!
Make rules, test rules, change rules until it works.
"Test-driven governance is like making a plan, testing the plan, and then changing the plan based on what we learned."
"Test first, then implement to make better decisions" - TDD for Governance.
"Test-driven governance is like following a recipe when you are cooking. First, you decide what you want to make, then you write down the steps you need to take, and finally, you check that you followed each step correctly. This helps make sure that what you make turns out the way you want it to, and you can make changes if needed." 
In test-driven governance, we set a goal, then create a plan that divides the goal into smaller tasks, called tests. We make sure that each test is passed before we take another step. This helps us be sure that we are headed in the right direction and that what we create will work well.
"Governance: because making decisions based on feelings is outdated."

Decentralized or federated systems offer greater resilience. Since the
data is stored in a distributed manner, there's no single point of
failure, reducing the disaster and attack risks. Decentralized systems
promote privacy when the data is encrypted by default, because it is
not held by one centralized authority that might have a conflict of
interest. Overall, decentralized platforms provide greater autonomy,
flexibility, and fairness, reducing the risk of fraud and corruption.
These platforms are adaptable and customizable to a wide range of
situations and needs, making them more flexible and accessible than
centrally-owned targeted tools. Overall, decentralized platforms
provide an environment for advancing vital work in project management,
event coordination, governance, software and gardware development, and
most other fields of human endeavor.  Decentralized systems avoid
reliance on a single legal entity -- decentralized and federated
systems are by definition owned my multiple parties.  Decentralization
avoids loss of community that can be caused by loss of a single legal
entity.  


Moreover, decentralized systems provide greater autonomy, flexibility,
and fairness, reducing the risks of fraud and corruption. They are
adaptable and customizable to a wide range of situations and needs,
making them more flexible and accessible than centrally-owned targeted
tools. Finally, decentralized systems avoid reliance on a single legal
entity or centralized power, promoting a more distributed
decision-making process and avoiding the loss of community that can
result from the loss of a single legal entity.

Tests are important in a decentralized system because they serve as
the rules for determining whether a commit should be accepted.  If the
tests were on a different timeline, it would be difficult to track
which version of the tests was used in the review process, leading to
potential conflicts and inconsistencies. To ensure transparency and
accuracy, tests on a timeline are designed to determine which branch
or version is considered the "trunk". In the event of a conflict, it
is important that the tests are on the same timeline to ensure that
changes and updates are reviewed and validated before being
implemented.

Decentralization is a core concept in CC and timeline-based governance
because it offers a number of benefits. By using decentralized systems
to store data, CC offers greater security, privacy, and resilience.
Decentralization helps to prevent a single point of failure, which can
reduce the risk of disasters and attacks. It also promotes privacy, as
the data is encrypted by default and not held by a single centralized
authority that might have a conflict of interest. 

In addition, decentralized platforms provide greater autonomy,
flexibility, and fairness, reducing the risk of fraud and corruption.
They are adaptable and customizable to a wide range of situations and
needs, making them more flexible and accessible than centrally-owned
targeted tools. Decentralized systems avoid loss of community that can
be caused by loss of a single legal entity. This is particularly
important in communities where decision-making processes are
distributed and based on collaboration, consensus, and participation.

Decentralized processing allows for greater resilience and security by
distributing computational tasks across a network of nodes in a
trustless, distributed environment. Designed to be independent of any
specific hardware or operating system, its execution is not dependent
on any single machine or entity. This decentralization makes the
decentralized machine more robust and resistant to failure or
interference from any one node.

In order to ensure consistency and accuracy, the testing process
provides a consensus mechanism to ensure that all nodes in the network
agree on the state of a timeline. This consensus mechanism allows the
network to function without relying on a central authority or
centralized data storage.

The system also allows for the creation of decentralized applications
that can be built on top of the platform. These apps can take
advantage of the decentralized nature of the system to provide secure
and trustless solutions to various problems. 


describe a low-level wire protocol that is based on lambda queries in
which the op code is a cryptographic hash of the lambda function's
code, operands are inputs to the function, and the result is
referentially transparent so is cacheable in a decentralized system


The proposed wire protocol is a low-level communication protocol based
on lambda queries. Each query contains a cryptographic hash of the
lambda function's code as the opcode, and the inputs to the lambda
function are passed as operands. The result of the lambda function is
deterministic and referentially transparent, making it possible to
cache the result in a decentralized system. 

For example, let's assume that we have a lambda function that
calculates the square of a number. The lambda function can be
represented as a code block, and we can generate a cryptographic hash
of the code block. This hash becomes the opcode of the query. 

When a client makes a request for the square of a number, it sends a
lambda query that contains the hash of the square function, along with
the number to be squared. The server receives the query, looks up the
result in its cache, and if it's not found, it executes the lambda
function, caches the result and returns it to the client. 

In this way, the wire protocol based on lambda queries allows us to
perform decentralized computations with minimal network overhead,
since the results of the lambda function can be cached and reused.
This makes it possible to build decentralized applications that are
both efficient and scalable.


describe how decentralized lambda systems are heterogeneous, allowing
participation from all actors, whether human or machine, mainfrome or
microcontroller, IoT or AI.


Decentralized lambda systems are heterogeneous because they allow for
multiple actors, regardless of whether they are human or machine, to
participate in the system. This means that the system is not limited
to a specific type of participant, and can include different devices
or technologies like mainframes, microcontrollers, IoT devices, and AI
systems.

The architecture of decentralized lambda systems allows for
flexibility in implementation, making it accessible to a highly
diverse set of actors. For example, a microcontroller can participate
in the system by implementing specific functions, while an AI system
can process data and provide insights based on the inputs received
from the other participants. 

Each participant is capable of contributing its unique capabilities
and expertise to the system, whether it's performing an essential task
or providing high-level analysis of the data. In this way, the system
can achieve a high level of flexibility and adaptability, making it
highly responsive to the changing needs of its participants or users. 


a system with a unique sensor can participate as well


Absolutely! Decentralized lambda systems are designed to be
heterogeneous, meaning that they can include participation from all
types of devices and machines, including sensors, microcontrollers,
and Internet of Things (IoT) devices. This means that a system with a
unique sensor can certainly participate in the decentralized lambda
system. In fact, the incorporation of sensors and other machines can
greatly enhance the capabilities of the system by allowing for
real-time data collection, analysis, and decision-making.
Additionally, machine learning tools can help to mediate consensus and
provide further insights into the data being collected and analyzed.
Overall, the decentralized nature of the system allows for seamless
participation from a wide variety of actors, whether human or machine.


How do i describe human participation in decentralized lambda systems
without making it sound like the humans are just cogs in a machine?


To describe human participation in decentralized lambda systems, it's
important to recognize that humans are not just cogs in a machine.
Decentralized systems are designed to promote participation and
collaboration between humans and machines, and to give agency and
autonomy to individuals and groups.

Decentralized systems are built on the idea of distributed
decision-making and consensus formation, where individuals are
empowered to make decisions, take action, and collaborate in a
trustless and transparent environment. Humans are key actors in these
systems, providing critical thinking, creativity, and social skills
that are difficult, if not impossible, for machines to replicate.

This collaborative environment allows for diverse perspectives,
experiences, and knowledge to be brought to the table, ultimately
leading to better decision-making and more innovative solutions. By
leveraging the strengths of both humans and machines, decentralized
systems can achieve levels of efficiency and scalability that would be
impossible for either group to achieve on their own.

Overall, human participation is a crucial aspect of decentralized
lambda systems, and one that should be valued and encouraged. These
systems are not just about technology, but about creating a more
cooperative, transparent, and equitable way of working together.


describe trustless


Trustless refers to a system in which interactions and transactions
can occur without the need for trusting a central authority or
intermediary. Instead, a trustless system is designed to rely on
cryptographic algorithms, consensus mechanisms, and other methods to
ensure security, transparency, and accountability without relying on a
trusted third party to manage the process. This means that users can
participate in the system without having to trust any individual or
entity, because the system is designed to ensure accuracy and fairness
without that reliance.


why is trustless important in a close community where the parties know
and trust each other?


While it may seem counterintuitive, trustless systems are still
important in a close community where the parties know and trust each
other because they help to ensure security, transparency, and
accountability. Even in a community where all parties are known and
trusted, there is still a risk of fraud or corruption if there is a
central authority or intermediary that manages the process. By
removing the need for a trusted third party, a trustless system can
improve the efficiency and fairness of transactions and interactions
while also promoting transparency and accountability. Additionally,
trustless systems can provide greater flexibility and adaptability
to changing circumstances compared to centrally-owned targeted
tools, which can be rigid and inflexible. Ultimately, trustless
systems can help close communities to achieve their goals in a more
democratic and collaborative way.


"trustless" really means "no central trusted third party needed"


Yes, that's correct! In a trustless system, interactions and
transactions can occur without relying on a central authority or
intermediary, because the system is designed to ensure accuracy and
fairness without that reliance.


why is it important to avoid reliance on central third parties?


It is important to avoid reliance on central third parties because
centralization often creates a single point of failure or
vulnerability, which can be exploited to harm the system or its users.
Third parties may have conflicts of interest, act maliciously or
incompetently, or be subject to censorship or interference by state
actors. By decentralizing decision-making, data storage, and other key
functions, individuals and communities can avoid these risks and build
more resilient, transparent, and accountable systems. Decentralization
promotes autonomy, flexibility, privacy, and fairness while reducing
the risks of fraud, corruption, and abuse. It also encourages
collaboration, innovation, and diversity by allowing more participants
to contribute to the system without fear of reprisal. Overall,
removing reliance on central third parties enables us to build more
equitable and democratic societies.


tell me about the relationship between decentralization, usenet, and
the early days of the internet, compared to today's more centralized
internet.  what are the downsides of the current situation?


In the early days of the internet, there was a strong emphasis on
decentralization, as evidenced by systems like Usenet. Usenet was a
distributed discussion system that relied on a network of
interconnected servers to share articles and messages. This allowed
for decentralized decision-making and data sharing, as well as
reducing the risk of a single point of failure or vulnerability.

However, in recent years, there has been a shift towards
centralization of the internet, as larger companies and platforms have
gained significant power and influence. These centralized platforms
often create a single point of control and can be subject to
censorship or interference from state actors. This can have negative
consequences for freedom of speech, privacy, and democracy.

The downsides of a centralized internet include the risk of data
breaches and the concentration of power in the hands of a few
companies. This can result in an uneven playing field for smaller
businesses and lead to a lack of innovation and diversity in the
technology sector. Additionally, centralized systems are often
inflexible and difficult to modify or scale, making it harder for
communities to adapt to changing circumstances.

In contrast, decentralized systems offer advantages such as greater
resilience, privacy, and autonomy. Decentralization promotes
collaboration, innovation, and diversity by allowing more participants
to contribute to the system without fear of reprisal. Decentralized
decision-making and data storage can also help prevent censorship or
interference from third parties. Overall, decentralization can lead to
a more equitable and democratic internet.


summarize the need for decentralization in CC by comparing it to the
early days of usenet and the internet versus now.


In the early days of the internet, systems like Usenet emphasized
decentralization which allowed for distributed decision-making and
data sharing, reducing the risk of a single point of failure. However,
in recent years, there has been a shift towards centralization in the
internet with larger companies and state actors gaining significant
power and influence. Decentralization in CC offers greater resilience,
privacy, and autonomy while preventing a single point of control or
interference. It promotes collaboration, innovation, and diversity
while allowing more participants to contribute to the system without
fear of reprisal leading to more equitable and democratic governance.


describe the relationship between decentralization, usenet, and the
distributed lambda system


Decentralization, Usenet, and the distributed lambda system are
related concepts that emphasize the importance of distributed decision
making and data sharing. Usenet, a distributed discussion system from
the early days of the internet, relied on interconnected servers to
share articles and messages, promoting decentralized decision making
and data sharing. Similarly, the distributed lambda system is based on
a wire protocol that allows for decentralized computations through
lambda queries. Each query contains a cryptographic hash of the lambda
function's code as the opcode, and the inputs to the function are
passed as operands. The result of the function is deterministic and
referentially transparent, making it possible to cache the result in a
decentralized system. Overall, decentralization promotes
collaboration, innovation, and diversity while reducing the risks of
fraud and interference from third parties. It also encourages a more
democratic and transparent way of working together.


docs are code


Yes, in a sense, documentation can be considered as code. Just as code
describes the behavior and structure of a program, documentation
describes the behavior and structure of a project or system.
Documentation also usually comes with its own set of rules and
formatting guidelines, similar to how code has syntax and style
conventions that must be followed. In a collaborative environment,
documentation can be checked into version control systems just like
code, and can be reviewed, tested, and revised just like code.


a timeline is a form of evolving documentation


Yes, that's correct. A timeline is a way to document the history and
future of a community or project through a series of events or
commits. It is also an evolving documentation because it can be
updated and modified over time as new information or changes occur.
The commits or events on a timeline are frozen and referenced using a
unique identifier or key, which helps to maintain the integrity of the
timeline and ensure that it is transparent and organized.
Additionally, timelines can have multiple branches to represent
different versions or scenarios, making them a versatile tool for
managing information, tracking progress, and exploring different
options or alternatives.


a timeline is code


Yes, a timeline can be thought of as a code or script that documents
the history and future of a community or project in a structured and
organized way. It consists of a series of commits, which can be seen
as units of code or events, that are referenced and linked to one
another to form a timeline. These commits are frozen and cannot be
modified, but new commits can be added to the timeline to update or
supersede previous ones. In this sense, a timeline can be seen as a
form of evolving documentation that is organized and structured like
code.


describe how WASM and caching relay servers using websocket are used
to create the decentralized system


WebAssembly (WASM) is a binary instruction format designed for web
browsers that allows code to run at near-native speeds. In a
decentralized system, it enables users to run code in a trustless
environment without relying on a centralized authority. In this way,
users can be sure that their code is executing correctly and that
their results are accurate.

Caching relay servers using WebSockets is another important tool in
creating a decentralized system. These servers help to overcome the
latency and bandwidth limitations of the internet by automatically
caching frequently accessed data on servers located closer to the
user's location. This can greatly reduce latency and increase overall
system performance.

Together, WASM and caching relay servers using WebSockets form the
backbone of a decentralized system. By enabling users to execute code
at near-native speeds and caching frequently accessed data, this
system creates a trustless, distributed environment that is both
efficient and scalable. It allows for the creation of decentralized
applications that are secure, transparent, and trustless, promoting
collaboration, innovation, and diversity while reducing the risks of
fraud and interference from third parties.


the cashing relay servers are also important in order to work around
private or natted IP addresses or firewalls keeping browsers from
seeing each other directly on public IPS


Yes, caching relay servers using WebSockets can play an essential role
in a decentralized system by helping to overcome the limitations of
traditional networking methods such as firewalls or NAT'd IP
addresses. WebSockets can establish a persistent connection between
the user's browser and the caching relay server, which can then cache
frequently accessed data and return it to the user more quickly. This
can help improve overall system performance, reduce network latency
and bandwidth limitations, and ensure that users can interact with
each other efficiently even when they are behind network barriers.


describe why a system such as CC was not possible until now due to
the recent maturity of technologies such as wasm


A system such as CC (Community Coordination) was not possible until
now due to the advances in technology and the internet. CC is based on
key principles such as parallel timeliness, collaboration, and
decentralization, and requires accessible and flexible tools and
technologies to function efficiently. With the advent of modern web
browsers, document management systems, version control systems, chat
platforms, and other such tools, it is now possible to implement a
system like CC that promotes collaboration, reduces workload, and
provides a transparent and open process for coordinating projects and
events. Additionally, the growing popularity of decentralized systems
has paved the way for the adoption of CC and its underlying principles
of decentralization and trustlessness.

The growing popularity of decentralized systems has also paved the way
for the adoption of CC, which promotes the principles of
decentralization and trustlessness. 

Additionally, the advent of technologies like WebAssembly (WASM) has
facilitated the creation of a decentralized system by enabling users
to run code in a trustless environment without the need for a
centralized authority.


list the main points


Based on the given text, here are the main points:

- CC or timeline-based governance is a process for managing projects
  or communities through a series of events or commits on a timeline.
- Timelines are an evolving documentation that can be updated and
  modified over time as new information or changes occur.
- A timeline consists of commits or events that are frozen and
  referenced using a unique identifier or key, which helps to ensure
  that it is transparent and organized.
- Changes to a timeline are made through a proposal and testing
  process, allowing for objection and conflict resolution.
- Decentralization is a core concept in CC and timeline-based
  governance as it offers greater security, privacy, and resilience,
  and helps to prevent a single point of failure.
- Parallel timelines can be used to maintain different versions or
  scenarios of a project or community.
- Multiple parties can work on different branches and test their
  changes independently without causing conflicts, and can then merge
  their changes using a proposal and testing process.
- Testing provides a clear course for decision-making and ensures that
  proposals or commits meet the criteria or rules described in prior
  commits.
- Timelines can be used to represent not only communities or projects
  but also procedures or policies.
- The downside of the current situation on the internet is
  centralization, as larger companies and state actors have gained
  significant power and influence, creating a single point of control
  that can be subject to interference.
- Decentralized lambda systems are heterogeneous, allowing
  participation from all actors, whether human or machine, mainframe
  or microcontroller, IoT or AI. This allows for flexibility and
  adaptability, making the system highly responsive to the changing
  needs of its participants or users.


if plans are timelines and timelines are code, then describe how the
halting problem affects the ability to plan


The halting problem is a well-known problem in computer science that
states that it is impossible to determine, in general, whether a given
program (or algorithm) will eventually halt or run forever. This has
important implications for planning, as plans are essentially
algorithms that describe a set of steps to achieve a certain goal.

If we consider plans to be timelines and timelines to be code, then
the halting problem could affect the ability to create effective and
reliable plans. Specifically, if we cannot determine whether a plan
will eventually succeed or fail, it becomes difficult to make informed
decisions about which plan to follow or how to adapt the plan if it
runs into unforeseen difficulties.

The halting problem can also affect the ability to evaluate the
effectiveness of a plan. If we cannot determine whether a plan will
eventually succeed or fail, it may be difficult to determine whether a
given plan will be successful or whether it needs to be revised or
abandoned.

In summary, the halting problem can have important implications for
planning, making it challenging to create effective and reliable
plans, evaluate their effectiveness, and make informed decisions about
how to adapt and revise them.

